









## Notifler

状态管理中的通知器

它负责接收UI事件，并调用业务逻辑（UseCase），然后管理状态并通知UI更新

### Notifler 可以复用吗？

可复用的场景：
  - Store 全局状态（如用户认证、APP theme）
  - 跨页面共享数据（如购物车数量徽章）
不可复用场景：
 - 页面专属状态（如订单页的多步骤表单）
 - 需要隔离的状态（避免不必要的重建）


### 使用场景

- 简单场景（仅展示数据， 简单少量状态）：
不用定义 Notifier ，直接使用 widget 状态。

- 复杂交互场景（支付页）：
专属Notifier + 多个UseCase
存放目录：`/views/{pageName}/providers`
比如：
支付页（PC）用 /views/checkout/providers/pc_checkout_notifier.dart (设备特有 Notifier， 没有则忽略) 和 /views/checkout/providers/checkout_notifier.dart (通用 Notifier)
支付页（Mobile）用 /views/checkout/providers/checkout_notifier.dart (通用 Notifier)

- 跨组件/页面共享状态
购物车、用户信息
全局Notifier
存放目录：`/applications/{feature}/provider`

### 注意
- 推荐按功能模块划分，而非简单按页面划分
- 避免在 Notifier 中写业务逻辑，只做状态更新和事件转发


## Repository

​DDD​​ 中 ​​仓储（Repository）模式​​

数据访问的抽象化​​：将数据存取逻辑抽象为接口，领域层不关心数据如何存储或获取

如果需要缓存，可以放在 Repository 层。


为 ​​领域模型​​ 提供统一的数据访问接口，屏蔽底层数据源（如网络 API、本地缓存）的细节。
<!-- 也就是旧 的 Service 网络层和 -->

应用层 -> 领域层 -> Repository -> API Client -> 后端

## UseCase

业务逻辑, 用例。

最佳实践是一个 UseCase 一个文件。

