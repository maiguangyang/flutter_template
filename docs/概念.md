<!--
 * @Author: Marlon.M
 * @Email: maiguangyang@163.com
 * @Date: 2024-08-06 07:06:08
-->

## Notifier

状态管理中的通知器。

它负责接收 UI 事件，并调用业务逻辑（Repository），然后管理状态并通知 UI 更新。

### Notifier 可以复用吗？

可复用的场景：
  - 全局状态（如用户认证、APP theme）
  - 跨页面共享数据（如购物车数量徽章）

不可复用场景：
 - 页面专属状态（如订单页的多步骤表单）
 - 需要隔离的状态（避免不必要的重建）


### 使用场景

- 简单场景（仅展示数据，简单少量状态）：
不用定义 Notifier，直接使用 widget 状态。

- 复杂交互场景（支付页）：
专属 Notifier + Repository
存放目录：`features/{pageName}/application/notifiers/`
比如：
支付页（PC）用 `features/checkout_screen/application/notifiers/pc_checkout_notifier.dart`（设备特有 Notifier，没有则忽略）和 `features/checkout_screen/application/notifiers/checkout_notifier.dart`（通用 Notifier）
支付页（Mobile）用 `features/checkout_screen/application/notifiers/checkout_notifier.dart`（通用 Notifier）

- 跨组件/页面共享状态
购物车、用户信息
全局 Notifier
存放目录：`shared/application/notifiers/`

### 注意
- 推荐按功能模块划分，而非简单按页面划分
- 避免在 Notifier 中写业务逻辑，只做状态更新和事件转发


## Repository

DDD 中仓储（Repository）模式。

数据访问的抽象化：将数据存取逻辑抽象为接口，领域层不关心数据如何存储或获取。

如果需要缓存，可以放在 Repository 层。

为领域模型提供统一的数据访问接口，屏蔽底层数据源（如网络 API、本地缓存）的细节。

存放目录：
- 共享：`shared/data/repositories/`
- Feature 独有：`features/{pageName}/data/repositories/`

数据流：

```
UI → Notifier → Repository → ApiService → 后端 API
```

## UseCase

业务逻辑，用例。

最佳实践是一个 UseCase 一个文件。


## 数据流架构图

```
┌─────────┐     ┌──────────┐     ┌────────────┐     ┌────────────┐     ┌──────┐
│   UI    │────▶│ Notifier │────▶│ Repository │────▶│ ApiService │────▶│ API  │
│ (Widget)│◀────│ (State)  │◀────│  (Data)    │◀────│  (HTTP)    │◀────│      │
└─────────┘     └──────────┘     └────────────┘     └────────────┘     └──────┘
  ref.watch       state =          聚合数据源         Dio + DTO          后端
                  copyWith         输出 Entity        序列化
```
